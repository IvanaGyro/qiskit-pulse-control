'''
This script provides functions to symbolically calculate the Magnus expansion
up to a specified order, using Sympy. The code is generated by ChatGPT's o1
model.
'''
from sympy.physics import paulialgebra
from sympy.physics import quantum
import sympy


def commutator(A: sympy.Matrix, B: sympy.Matrix) -> sympy.Expr | sympy.Matrix:
    '''
    Compute the commutator [A, B] using sympy.physics.quantum.Commutator.

    Args:
        A (sympy.Matrix): The first matrix or operator.
        B (sympy.Matrix): The second matrix or operator.

    Returns:
        sympy.Expr or sympy.Matrix: The expanded commutator [A, B] = A*B - B*A.
    '''
    return paulialgebra.evaluate_pauli_product(
        quantum.Commutator(A, B).doit().expand())


def matrix_integrate(M: sympy.Matrix, var: sympy.Symbol, lower: sympy.Expr,
                     upper: sympy.Expr) -> sympy.Matrix:
    '''Integrate each entry of a sympy Matrix with respect to a variable.

    Args:
        M (sympy.Matrix): Matrix whose entries are integrable functions.
        var (sympy.Symbol): The variable of integration.
        lower (sympy.Expr): The lower limit of integration.
        upper (sympy.Expr): The upper limit of integration.

    Returns:
        sympy.Matrix: A matrix where each entry is the integral of the corresponding
            entry in M from `lower` to `upper`.
    '''
    if isinstance(M, sympy.Matrix):
        return M.applyfunc(lambda x: sympy.integrate(x, (var, lower, upper)))
    # Assume M is a linear combination of Puali matrices.
    M = M.expand()
    coeffs = {
        paulialgebra.Pauli(i): sympy.factor(
            M.coeff(paulialgebra.Pauli(i))) for i in [1, 2, 3]
    }
    return sum(
        sympy.integrate(c, (var, lower, upper)).doit() * m for m, c in coeffs.items())


def magnus_expansion(H: sympy.Matrix,
                     t: sympy.Symbol,
                     order: int = 3) -> sympy.Matrix:
    '''Compute the Magnus expansion up to a specified order.

    This function assumes that H(t) is a matrix-valued function of the
    symbolic variable t. It will compute the Magnus expansion terms:

    1) First order: Omega_1(t) = ∫[0 to t] H(t1) dt1
    2) Second order: Omega_2(t) = 1/2 ∫[0 to t] dt1 ∫[0 to t1] dt2 [H(t1), H(t2)]
    3) Third order: Omega_3(t) = 1/6 ∫[0 to t] dt1 ∫[0 to t1] dt2 ∫[0 to t2] dt3 (
           [H(t1), [H(t2), H(t3)]] + [H(t3), [H(t2), H(t1)]] )

    Args:
        H (sympy.Matrix): Matrix or operator whose entries are functions of t.
        t (sympy.Symbol): The variable of integration.
        order (int): Maximum order of the Magnus expansion to compute.

    Returns:
        sympy.Matrix: The symbolic expression for the Magnus expansion,
            Omega(t) = Omega_1 + Omega_2 + Omega_3, up to the specified order.
    '''
    if order not in (1, 2, 3):
        raise ValueError(f'Invalid order: {order}')

    # 1) First-order term: Omega1 = ∫[0 to t] H(τ) dτ
    t1 = sympy.Symbol('t1', real=True, nonnegative=True)
    H_t1 = H.subs(t, t1)
    Omega1 = matrix_integrate(H_t1, t1, 0, t)
    Omega = Omega1

    if order == 1:
        return Omega

    # 2) Second-order term: (1/2) ∫[0 to t] dt1 ∫[0 to t1] dt2 [H(t1), H(t2)]
    if order >= 2:
        t1 = sympy.Symbol('t1', real=True, nonnegative=True)
        t2 = sympy.Symbol('t2', real=True, nonnegative=True)

        H_t1 = H.applyfunc(lambda x: x.subs(t, t1))
        H_t2 = H.applyfunc(lambda x: x.subs(t, t2))

        comm_t1_t2 = commutator(H_t1, H_t2)
        partial_t2 = matrix_integrate(comm_t1_t2, t2, 0, t1)
        partial_t1 = matrix_integrate(partial_t2, t1, 0, t)

        Omega2 = sympy.Rational(1, 2) * partial_t1
        Omega += Omega2
    else:
        return Omega

    # 3) Third-order term
    if order >= 3:
        t1 = sympy.Symbol('t1', real=True, nonnegative=True)
        t2 = sympy.Symbol('t2', real=True, nonnegative=True)
        t3 = sympy.Symbol('t3', real=True, nonnegative=True)

        H_t1 = H.applyfunc(lambda x: x.subs(t, t1))
        H_t2 = H.applyfunc(lambda x: x.subs(t, t2))
        H_t3 = H.applyfunc(lambda x: x.subs(t, t3))

        comm_t2_t3 = commutator(H_t2, H_t3)
        part1 = commutator(H_t1, comm_t2_t3)

        comm_t2_t1 = commutator(H_t2, H_t1)
        part2 = commutator(H_t3, comm_t2_t1)

        integrand = part1 + part2

        step_t3 = matrix_integrate(integrand, t3, 0, t2)
        step_t2 = matrix_integrate(step_t3, t2, 0, t1)
        step_t1 = matrix_integrate(step_t2, t1, 0, t)

        Omega3 = sympy.Rational(1, 6) * step_t1
        Omega += Omega3

    return Omega


if __name__ == '__main__':
    # Example usage
    t_sym = sympy.Symbol('t', real=True, nonnegative=True)

    # Define a 2x2 example matrix
    H_example = sympy.Matrix([[0, t_sym], [-t_sym, 0]])

    # Compute up to 2nd order
    Omega_2 = magnus_expansion(H_example, t_sym, order=2)
    print('Omega up to 2nd order:\n', Omega_2)

    # Compute up to 3rd order
    Omega_3 = magnus_expansion(H_example, t_sym, order=3)
    print('\nOmega up to 3rd order:\n', Omega_3)
